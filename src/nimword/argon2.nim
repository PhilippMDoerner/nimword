import std/[strformat, base64, strutils]
import libsodium/[sodium, sodium_sizes]

export sodium.PasswordHashingAlgorithm

proc toBytes(s: string): seq[byte] =
  result = cast[ptr seq[byte]](unsafeAddr s)[]

proc encodeHash*(
  hash: string, 
  salt: seq[byte], 
  iterations: int, 
  algorithm: PasswordHashingAlgorithm;
  memoryLimitBytes: int;
): string =
  ## Encodes all relevant data for a password hash in a string, with both
  ## salt and hash being base64 encoded. The pattern is:
  ## <algorithm>$v=<version>$m=<memoryLimit>,t=<iterations>,p=<number of threads>$<salt>$<hash>
  var encodedSalt = salt.encode()
  encodedSalt.removeSuffix('=')

  let memoryLimitKiloBytes = (memoryLimitBytes / 1024).int
  let algorithmStr = case algorithm:
    of phaDefault, phaArgon2id13:
      "argon2id"
    of phaArgon2i13:
      "argon2i"

  result = fmt"${algorithmStr}$v=19$m={memoryLimitKiloBytes},t={iterations},p=1${encodedSalt}${hash}"

proc encodeHash*(
  hash: string, 
  salt: string, 
  iterations: int, 
  algorithm: PasswordHashingAlgorithm;
  memoryLimit: int;
): string =
  encodeHash(hash, salt.toBytes(), iterations, algorithm, memoryLimit)

proc hashPassword*(
  password: string, 
  salt: string, 
  iterations: int = crypto_pwhash_opslimit_moderate().int,
  hashLength: int = 32,
  algorithm: PasswordHashingAlgorithm = phaDefault,
  memorylimit: int = crypto_pwhash_memlimit_moderate().int
): string =
  ## Derive an ``outlen`` long key from a password ``passwd`` whose length is in
  ## between ``crypto_pwhash_passwd_min()`` and ``crypto_pwhash_passwd_max()``
  ## and a salt of fixed length of ``crypto_pwhash_saltbytes()``.
  ##
  ## ``outlen`` should be at least ``crypto_pwhash_bytes_min()`` and at most
  ## ``crypto_pwhash_bytes_max()``
  ##
  ## See also:
  ## * `crypto_pwhash_str proc <#crypto_pwhash_str,string>`_
  let hashBytes = crypto_pwhash(
    password, 
    salt.toBytes(), 
    hashLength, 
    algorithm, 
    iterations.csize_t, 
    memoryLimit.csize_t
  )
  result = hashBytes.encode()
  result.removeSuffix("=")

proc hashEncodePassword*(
  password: string, 
  iterations = crypto_pwhash_opslimit_moderate().int,
  alg = phaDefault,
  memlimit = crypto_pwhash_memlimit_moderate().int
): string =
  result = crypto_pwhash_str(password, alg, iterations.csize_t, memlimit.csize_t)   ## 
  ## Returns an ASCII encoded string which includes:
  ## * the result of the chosen hash algorithm ``alg`` applied to the
  ##   password ``passwd`` (the default is a memory-hard, CPU-intensive hash
  ##   function). The password length must be in the range
  ##   between ``crypto_pwhash_passwd_min()`` and ``crypto_pwhash_passwd_max()``
  ## * the automatically generated salt used for the previous computation.
  ## * the other parameters required to verify the password.
  ##
  ## The returned string includes only ASCII characters and can be safely
  ## stored into SQL databases and other data stores.
  ##
  ## See also:
  ## * `crypto_pwhash proc <#crypto_pwhash,string,openArray[byte],Natural>`_
  ## * `crypto_pwhash_str_verify proc <#crypto_pwhash_str_verify,string,string>`_

proc isValidPassword*(password: string, encodedHash: string): bool =
  ## Verifies that str is a valid password verification string (as generated by
  ## ``crypto_pwhash_str()``) for ``passwd``
  ##
  ## See also:
  ## * `crypto_pwhash_str proc <#crypto_pwhash_str,string>`_
  result = crypto_pwhash_str_verify(encodedHash, password) 